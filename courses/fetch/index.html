<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="../reveal.css">
    <link rel="stylesheet" href="../black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="../monokai.css">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <section>
                    <h1>Promise</h1>
                </section>
                <section>
                    <p>Представьте, что вы известный певец, которого фанаты постоянно донимают расспросами о предстоящем
                        сингле.<br />
                        Чтобы получить передышку, вы обещаете разослать им сингл, когда он будет выпущен. Вы даёте
                        фанатам список, в который они могут записаться. Они могут оставить там свой e-mail, чтобы
                        получить песню, как только она выйдет. И даже больше: если что-то пойдёт не так, например, в
                        студии будет пожар и песню выпустить не выйдет, они также получат уведомление об этом.</p>
                    <aside class="notes">
                        <p>Все счастливы! Вы счастливы, потому что вас больше не донимают фанаты, а фанаты больше не
                            беспокоятся, что пропустят новый сингл.</p>
                    </aside>
                </section>
                <section>
                    <ul>
                        <li> Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные
                            по сети.</li>
                        <li> Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет
                            готов.</li>
                        <li> Promise &mdash; это специальный объект, который связывает «создающий» и «потребляющий» коды
                            вместе. </li>
                    </ul>
                    <aside class="notes">
                        <p>"Создающий" &mdash; певец, "потреблябщий" &mdash; фанаты.</p>
                        <p>В терминах нашей аналогии – это «список для подписки».<br />
                            «Создающий» код может выполняться сколько потребуется,
                            чтобы получить результат, а промис делает результат доступным для кода, который подписан на
                            него, когда результат готов</p>
                        <p>Аналогия не совсем точна, потому что объект Promise в JavaScript гораздо сложнее простого
                            списка подписок: он обладает дополнительными возможностями и ограничениями.</p>
                    </aside>
                </section>
                <section>
                    <pre><code>let promise = new Promise(function(resolve, reject) {
    // функция-исполнитель (executor)
    // "певец"
  });</code></pre>
                    <aside class="notes">
                        <p>Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда
                            Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код,
                            который когда-нибудь создаст результат. В терминах нашей аналогии: исполнитель – это
                            «певец».<br />

                            Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код –
                            только внутри исполнителя.</p>
                    </aside>
                </section>
                <section>
                    <p>Когда Promise получает результат, он должен вызвать один из этих колбэков:
                    <ul>
                        <li>resolve(value) — если работа завершилась успешно, с результатом value</li>
                        <li>reject(error) — если произошла ошибка, error – объект ошибки</li>
                    </ul>
                    Исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или
                    reject</p>
                </section>
                <section>
                    <p>У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
                    <ul>
                        <li>state («состояние») &mdash; вначале "pending" («ожидание»), потом меняется на "fulfilled"
                            («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при
                            вызове reject</li>
                        <li>result («результат») &mdash; вначале undefined, далее изменяется на value при вызове
                            resolve(value) или на error при вызове reject(error)</li>
                    </ul>
                    </p>
                </section>
                <section>
                    <img src="./01.svg" />
                </section>
                <section>
                    <p>Пример конструктора Promise и простого исполнителя</p>
                    <pre><code>let promise = new Promise(function(resolve, reject) {
    // эта функция выполнится автоматически, при вызове
    // через 1 секунду сигнализировать, что задача выполнена
    setTimeout(() => resolve("done"), 1000);
  });</code></pre>
                    <ul>
                        <li>Функция-исполнитель запускается сразу при вызове new Promise</li>
                        <li>resolve и reject &mdash; встроенные функции JavaScript</li>
                        <li>Исполнитель должен вызвать одну из функций по готовности</li>
                    </ul>
                </section>
                <section>
                    <img src="./02.svg" />
                </section>
                <section>
                    <img src="./03.svg" />
                    <pre><code>let promise = new Promise(function(resolve, reject) {
    // спустя одну секунду будет сообщено, 
    //что задача выполнена с ошибкой
    setTimeout(() => reject(new Error("Whoops!")), 1000);
  });</code></pre>
                </section>
                <section>
                    <p>Потребители: then, catch</p>
                    <p>Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и
                        функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку.
                        Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов .then и .catch.
                    </p>
                </section>
                <section>
                    <p>then</p>
                    <pre><code>promise.then(
    function(result) { /* обработает успешное выполнение */ },
    function(error) { /* обработает ошибку */ }
  );</code></pre>
                    <pre><code>let promise = new Promise(function(resolve, reject) {
    setTimeout(() => resolve("done!"), 1000);
  });
  
  // resolve запустит первую функцию, переданную в .then
  promise.then(
    result => console.log(result), // выведет "done!" через одну секунду
    error => console.log(error) // не будет запущена
  );</code></pre>
                </section>
                <section>
                    <p>В случае ошибки в промисе:</p>
                    <pre><code>let promise = new Promise(function(resolve, reject) {
    setTimeout(() => reject(new Error("Whoops!")), 1000);
  });
  
  // reject запустит вторую функцию, переданную в .then
  promise.then(
    result => console.log(result), // не будет запущена
    error => console.log(error) // выведет "Error: Whoops!"
  );</code></pre>
                </section>
                <section>
                    <p>Если заинтересованы только в результате, то передается только одна функция:</p>
                    <pre><code>let promise = new Promise(resolve => {
    setTimeout(() => resolve("done!"), 1000);
  });
  
  promise.then(console.log); // выведет "done!"</code></pre>
                </section>
                <section>
                    <p>catch</p>
                    <pre><code>let promise = new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error("Ошибка!")), 1000);
  });
// .catch(f) это то же самое, что promise.then(null, f)
  promise.catch(console.log); // выведет "Error: Ошибка!"</code></pre>
                    <p>Вызов .catch(f) – это сокращённый, «укороченный» вариант .then(null, f).</p>
                </section>
                <section>
                    <p>Очистка: finally</p>
                    <p>Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда
                        промис завершится: успешно или с ошибкой.</p>
                    <pre><code>new Promise((resolve, reject) => {
    /* сделать что-то, что займёт время, и после вызвать 
    resolve или может reject */
  })
    // выполнится, когда промис завершится, 
    // независимо от того, успешно или нет
    .finally(() => остановить индикатор загрузки)
    // таким образом, индикатор загрузки всегда 
    // останавливается, прежде чем мы продолжим
    .then(result => показать результат, 
          err => показать ошибку)</code></pre>
                    <aside class="notes">
                        <p>Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после
                            завершения предыдущих операций.<br />
                            Обратите внимание, что finally(f) – это не совсем псевдоним then(f,f), как можно было
                            подумать.<br />
                        <ol>
                            <li>Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был
                                завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие»
                                завершающие процедуры</li>
                            <li>Обработчик finally не имеет аргументов, а результат промиса обрабатывается в следующем
                                обработчике</li>
                            <li>Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам
                            </li>
                            <li>Обработчик finally не должен ничего возвращать.</li>
                        </ol>
                        </p>
                    </aside>
                </section>
                <section>
                    <p>Результат проходит через finally к then:</p>
                    <pre><code>new Promise((resolve, reject) => {
    setTimeout(() => resolve("value"), 2000);
  })
    .finally(() => console.log("Промис завершён")) // срабатывает первым
    .then(result => console.log(result)); // .then показывает "value"</code></pre>
                </section>
                <section>
                    <p>Ошибка из промиса проходит через finally к catch:</p>
                    <pre><code>new Promise((resolve, reject) => {
                        throw new Error("error");
                      })
                        .finally(() => alert("Промис завершён")) // срабатывает первым
                        .catch(err => alert(err));  // .catch показывает ошибку</code></pre>
                </section>
                <section>
                    <h4>Итоги:</h4>
                    <ul>
                        <li>Обработчик finally не получает результат предыдущего обработчика. Вместо этого этот
                            результат передается следующему подходящему обработчику</li>
                        <li>Если обработчик finally возвращает что-то, это игнорируется</li>
                        <li>Когда finally выдает ошибку, выполнение переходит к ближайшему обработчику ошибок</li>
                    </ul>
                </section>
            </section>






            <section>
                <section>
                    <h1>Fetch</h1>
                </section>
                <section>
                    <p>
                        JavaScript может отправлять сетевые запросы на сервер и подгружать новую информацию по мере
                        необходимости.<br />
                        Например, мы можем использовать сетевой запрос, чтобы:
                    <ul>
                        <li>Отправить заказ</li>
                        <li>Загрузить информацию о пользователе</li>
                        <li>Запросить последние обновления с сервера</li>
                        <li>…и т.п</li>
                    </ul>
                    Метод <b>fetch()</b> &mdash; современный и очень мощный.</p>
                </section>
                <section>
                    <p>Базовый синтаксис:</p>
                    <pre><code>let promise = fetch(url, [options])</code></pre>
                    <ul style="list-style-type: none;">
                        <li>url &mdash; URL для отправки запроса</li>
                        <li>options &mdash; дополнительные параметры</li>
                    </ul>
                    <aside class="notes">
                        Без options это простой GET-запрос, скачивающий содержимое по адресу url.<br />
                        Браузер сразу же начинает запрос и возвращает promise, который внешний код использует для
                        получения результата.<br />
                        Процесс получения ответа обычно происходит в два этапа.<br />
                        options &mdash; метод, заголовки и так далее
                    </aside>
                </section>
                <section>
                    <ol>
                        <li>promise выполняется с объектом встроенного класса Response в качестве результата, как только
                            сервер пришлёт заголовки ответа.</li>
                        <li>для получения тела ответа нужно использовать дополнительный вызов метода.</li>
                    </ol>
                </section>
                <section>
                    <p>Этап 1.</p>
                    <pre><code>let response = await fetch(url);

if (response.ok) { // если HTTP-статус в диапазоне 200-299
  // получаем тело ответа
  let json = await response.json();
} else {
  console.log("Ошибка HTTP: " + response.status);
}</code></pre>
                    <aside class="notes">
                        <p>На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно,
                            а
                            также посмотреть заголовки, но пока без тела ответа.<br />
                            Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке
                            сети или если нет такого сайта. HTTP-статусы 404 и 500 не являются ошибкой.</p>
                    </aside>
                </section>
                <section>
                    <p>Этап 2.<br />
                        Response предоставляет несколько методов, основанных на promise, для доступа к телу ответа в
                        различных форматах:
                    <ul>
                        <li>response.text()</li>
                        <li>response.json()</li>
                        <li>response.formData()</li>
                        <li>response.blob()</li>
                        <li>response.arrayBuffer()</li>
                    </ul>
                    </p>
                    <aside class="notes">
                        <ul>
                            <li>response.text() – читает ответ и возвращает как обычный текст</li>
                            <li>response.json() – декодирует ответ в формате JSON</li>
                            <li>response.formData() – возвращает ответ как объект FormData</li>
                            <li>response.blob() – возвращает объект как Blob (бинарные данные с типом)</li>
                            <li>response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление
                                бинарных данных)</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <p>Получим JSON-объект с последними коммитами из репозитория на GitHub:</p>
                    <pre><code>let url = 'https://golnk.ru/ZaRVJ';
let response = await fetch(url);
let commits = await response.json(); // ответ в формате JSON
console.log(commits[0].author.login);</code></pre>
                    <p>или тоже без await</p>
                    <pre><code>fetch('https://golnk.ru/ZaRVJ')
.then(response => response.json())
.then(commits => console.log(commits[0].author.login));</code></pre>
                </section>
                <section>
                    <p>Для получения ответа в виде текста используется <b>await response.text()</b> вместо
                        <b>await response.json()</b>:
                    </p>
                    <pre><code>let response = await fetch('https://golnk.ru/ZaRVJ');
let text = await response.text(); // тело ответа как текст      
console.log(text.slice(0, 80) + '...');</code></pre>
                </section>
                <section>
                    <p style="color: red;">Важно</p>
                    <p>Можно выбрать только один метод чтения ответа.<br />
                        Если мы уже получили ответ с <b>response.text()</b>, тогда <b>response.json()</b> не сработает,
                        так как данные уже были обработаны.</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>Заголовки ответа</h2>
                    <!-- </section>
                <section> -->
                    <p>Заголовки ответа хранятся в объекте <b>response.headers</b>.</p>
                    <pre><code>let response = await fetch('https://golnk.ru/ZaRVJ');
// получить один заголовок
console.log(response.headers.get('Content-Type')); 
// application/json; charset=utf-8

// перебрать все заголовки
for (let [key, value] of response.headers) {
    console.log(`${key} = ${value}`);
}</code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>Post-запросы</h2>
                    <!-- </section>
                <section> -->
                    <p>Для отправки POST-запроса или запроса с другим методом, необходимо использовать fetch с
                        <b>options</b>:
                    </p>
                    <ul>
                        <li> method – HTTP метод, например POST</li>
                        <li> body – тело запроса, одно из списка:</li>
                        <ul>
                            <li>строка (например, в формате JSON)</li>
                            <li>объект FormData для отправки данных как form/multipart</li>
                            <li>Blob/BufferSource для отправки бинарны данных</li>
                        </ul>
                    </ul>
                </section>
                <section>
                    <p>Чаще всего используется JSON.</p>
                    <pre><code>  let user = {
    name: 'John',
    surname: 'Smith'
  };
  let response = await fetch('/article/fetch/post/user', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json;charset=utf-8'
    },
    body: JSON.stringify(user)
  });
  let result = await response.json();
  console.log(result.message);</code></pre>
                </section>
            </section>
        </div>
    </div>

    <script src="../reveal.js"></script>
    <script src="../notes.js"></script>
    <!-- <script src="markdown.js"></script> -->
    <!-- <script src="../math/math.js"></script> -->
    <script src="../highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,
            showSlideNumber: 'all',
            slideNumber: "true",
            transition: "none",
            // Learn about plugins:</b> https://revealjs.com/plugins/
            plugins: [RevealHighlight, RevealNotes]
            // plugins: [RevealHighlight, RevealNotes, RevealMath.KaTeX]
        });
    </script>
</body>

</html>