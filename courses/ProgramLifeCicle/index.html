<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="../reveal.css">
    <link rel="stylesheet" href="../black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="../monokai.css">
    <!-- https://habr.com/ru/companies/kaiten/articles/893866/ -->
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h1>Жизненный цикл разработки ПО</h1>
                <p align="right">&copy; <a href="mailto:ipigp@yandex.ru">Игорь Григорьевич Пеймер</a></p>
                <aside class="notes">
                    <p>Software Development Life Cycle (SDLC) &mdash; это фундамент, на котором строится разработка. Он
                        помогает выстроить процессы так, чтобы команда четко понимала, что и когда ей нужно делать, а
                        заказчик
                        знал, на каком этапе находится работа. </p>
                </aside>
            </section>

            <section>
                <section>
                    <h2>Краткая история развития программирования</h2>
                </section>
                <section>
                    <img src="./1.jpg" /><br />
                    <sup>Структура взаимодействия узлов вычислительной машины</sup>
                    <aside class="notes">
                        С появлением первой вычислительной машины возникла необходимость управлять процессом
                        вычисления, задавать алгоритм решения задачи, т.е. составлять необходимую программу действий
                        (команд) машины. Первые вычислительные машины имели относительно большой набор (десятки)
                        команд, составляющих в общей сложности машинный язык.

                        Все команды были реализованы аппаратно, а программа представляла собой последовательность
                        команд и данных в числовом виде. Во время своего выполнения она вместе с обрабатываемыми
                        данными хранилась в памяти вычислительной машины (рис. 0.1). Команды последовательно
                        выбирались процессором из памяти. Вычислительные команды выполнялись в самом процессоре. Для
                        этого из памяти выбирались данные по адресам, прочитанным из исполняемой команды. Результаты
                        вычислений записывались в память.

                        Если очередная выбранная команда требовала обмена (ввода или вывода) данных, то она
                        передавалась на исполнение в процессор ввода/вывода. Последний активизировал соответствующее
                        внешнее устройство (ВНУ) и обеспечивал пересылку данных либо из памяти машины во внешнее
                        устройство, например для печати, либо от внешнего устройства в память машины.
                    </aside>
                </section>
                <section>
                    <img src="./1.jpg" /><br />
                    <sup>Структура взаимодействия узлов вычислительной машины</sup>
                    <aside class="notes">
                        Подобные процессоры ввода/вывода иногда называли каналами обмена. Различались селекторные
                        каналы, которые, начав обмен с одним ВНУ, не прекращали его до полного завершения, и
                        мультиплексные каналы. Последние могли параллельно поддерживать обмен с несколькими внешними
                        устройствами. Как правило, это были относительно медленные устройства, которые уступали по
                        быстродействию каналу и памяти в десятки раз.
                    </aside>
                </section>
                <section>
                    <img src="./1.jpg" /><br />
                    <sup>Структура взаимодействия узлов вычислительной машины</sup>
                    <aside class="notes">

                        Позднее широкое распространение получила архитектура вычислительных машин с так называемой
                        "общей шиной". Под этим термином понималась общая для всех устройств линия связи, включающая
                        средства передачи и адресов, и данных.
                    </aside>
                </section>
                <section>
                    <img src="./1.jpg" /><br />
                    <sup>Структура взаимодействия узлов вычислительной машины</sup>
                    <aside class="notes">

                        Все блоки вычислительной установки: и память, и процессор, и внешние устройства -
                        подключались к этой общей шине (рис. 0.2). Каждое такое устройство откликалось на появление
                        на шине "своего" адреса или, правильнее сказать, адреса из своего диапазона. Конечно,
                        диапазоны различных устройств, подключенных к общей шине, не пересекались.
                    </aside>
                </section>
                <section>
                    <img src="./1.jpg" /><br />
                    <sup>Структура взаимодействия узлов вычислительной машины</sup>
                    <aside class="notes">

                        Архитектура с общей шиной позволяла проще наращивать периферийные (внешние) устройства
                        вычислительной установки, которые сами брали на себя функции обмена с памятью
                        (взаимодействия с шиной). По пропускной способности подобные вычислительные установки
                        различали "узкие" и "широкие" общие шины.
                    </aside>
                </section>
                <section>
                    <img src="./2.jpg" /><br />
                    <sup>Структура с общей шиной</sup>
                    <aside class="notes">
                        В "узких" шинах и адрес, и сами данные последовательно передавались по одним и тем же
                        проводникам. Поэтому возможна была ситуация, при которой для выборки одного 8-разрядного символа
                        из оперативной памяти необходимо было затратить три такта обмена: два на передачу 16-разрядного
                        адреса символа и еще один на получение самого символа.
                    </aside>
                </section>
                <section>
                    <img src="./2.jpg" /><br />
                    <sup>Структура с общей шиной</sup>
                    <aside class="notes">

                        В "широких" шинах обмен адресной информацией и данными производился по независимым линиям, что
                        позволяло в одном такте выставить на шину и адрес, и значение. Причем шина данных могла
                        позволить пересылать сразу не восемь (один символ), а шестнадцать разрядов (два символа или
                        целое слово), что еще поднимало возможную скорость обмена.
                    </aside>
                </section>
                <section>
                    <img src="./2.jpg" /><br />
                    <sup>Структура с общей шиной</sup>
                    <aside class="notes">
                        Некоторые команды процессора вызывали изменение последовательной выборки команд. В результате их
                        выполнения вырабатывался адрес очередной выполняемой команды. Обычно значение этого адреса
                        зависело от ранее вычисленных в процессоре значений данных. Например, если результат вычислений
                        был нулевой, то вместо выборки следующей по порядку команды процессор переходил к выполнению
                        команды по заданному в ней адресу.
                    </aside>
                </section>
                <section>
                    <img src="./2.jpg" /><br />
                    <sup>Структура с общей шиной</sup>
                    <aside class="notes">

                        Такие команды часто называли командами условного перехода. Они определяли не только адрес
                        следующей выполняемой команды, но и условие, при котором этот адрес должен был быть использован,
                        например переход по нулевому значению, переход по отрицательному значению, переход по
                        переполнению и т.п.
                    </aside>
                </section>
                <section>
                    <img src="./2.jpg" /><br />
                    <sup>Структура с общей шиной</sup>
                    <aside class="notes">
                        Исходный код программы чаще всего подготавливался на перфорированном носителе (перфокартах или
                        перфоленте), где дырочки- пробивки представляли единицу, а отсутствие дырочки соответствовало
                        нулевому значению. Такая программа попадала в память через внешнее устройство ввода перфокарт
                        или перфоленты.
                    </aside>
                </section>
                <section>
                    <img src="./2.jpg" /><br />
                    <sup>Структура с общей шиной</sup>
                    <aside class="notes">

                        Мало-мальски сложная программа становилась трудночитаемой даже для автора, и круг пользователей
                        вычислительных машин был невелик. В основном он состоял из конструкторов вычислительной техники.
                        Порой "отладка" программы сопровождалась внесением изменений в саму машину. С дальнейшим ростом
                        сложности решаемых задач стало ясно, что "язык общения" человека и машины нуждается в
                        совершенствовании.
                    </aside>
                </section>
                <section>
                    <img src="./2.jpg" /><br />
                    <sup>Структура с общей шиной</sup>
                    <aside class="notes">
                        Изображение машинных команд в виде условных сокращений слов или символов (СЛ - сложить, ВЫЧ -
                        вычесть, УМ - умножить и т.д.) стало первым шагом от кодов машины в сторону человека, а
                        полученный язык кодирования программ называли ассемблером или мнемокодом. Программы стали более
                        читабельными, но для перевода из мнемонического описания программы в машинные коды понадобился
                        транслятор. Язык ассемблера теперь существует практически для любой машины, и на нем до сих пор
                        пишут системные программы, требующие работы со специфичными аппаратными возможностями
                        вычислителя, а также в случае серьезных ограничений на быстродействие и память при
                        программировании микроконтроллеров.
                    </aside>
                </section>
                <section>
                    <img src="./2.jpg" /><br />
                    <sup>Структура с общей шиной</sup>
                    <aside class="notes">

                        Параллельно с появлением первых языков программирования появилось разделение пользователей
                        вычислительной техники на классы: программисты, эксплуатационщики и так называемые "конечные
                        пользователи". Основной работой программистов стало составление программ. Эксплуатационщики
                        (иногда их называли электронщики) должны были обеспечивать работоспособность вычислительной
                        техники, надежность которой оставляла желать лучшего. А конечные пользователи решали с помощью
                        программ прикладные задачи, обеспечивая их для этого необходимыми данными.
                    </aside>
                </section>
                <section>
                    <img src="./2.jpg" /><br />
                    <sup>Структура с общей шиной</sup>
                    <aside class="notes">
                        Необходимость трансляции текста программы в машинный код породила целый класс новых задач.
                        Написание инструментальных (системных) программ стало самостоятельной областью деятельности
                        отдельной группы программистов. Чаще всего их стали называть системными программистами.
                    </aside>
                </section>
                <section>
                    <img src="./2.jpg" /><br />
                    <sup>Структура с общей шиной</sup>
                    <aside class="notes">
                        Силами системных программистов были созданы специализированные редакторы текстов,
                        предназначенные для подготовки программ, и трансляторы, переводящие исходные тексты программ в
                        машинный код. Для поддержки коллективной модульной разработки были написаны программы-сборщики,
                        которые позволяют объединить несколько независимо разработанных модулей в одну единую
                        выполняемую программу. Наконец, были созданы управляющие программы - операционные системы,
                        задача которых заключается в организации совместного выполнения нескольких программ на одной
                        вычислительной установке, перераспределяя вычислительные ресурсы между ними по мере
                        необходимости.
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h2>Языки высокого уровня</h2>
                </section>
                <section>
                    <p>Свойства языков высокого уровня:</p>
                    <ul>
                        <li> запись математических выражений в привычной для человека
                            алгебраической форме;</li>
                        <li>возможность конструировать новые типы данных;</li>
                        <li> создание собственных функций, библиотек;</li>
                        <li> возможностью использовать переменные с понятными человеку именами;</li>
                        <li> слабая зависимость от используемой вычислительной машины.</li>
                    </ul>
                    <aside class="notes">
                        Следующим шагом в развитии средств общения компьютера и человека стало появление языков высокого
                        уровня. Так как перед выполнением программы ее все равно было необходимо транслировать, то
                        решили
                        изменить сам язык написания программы. В него добавили новые команды, не имеющие соответствующих
                        машинных аналогов, но реализуемые набором аппаратных команд. Это упростило понимание программы и
                        облегчило ее составление. Сами языки высокого уровня по сравнению с ассемблером стали обладать
                        определенными свойствами:
                    </aside>
                </section>
                <section>
                    <p>Свойства языков высокого уровня:</p>
                    <ul>
                        <li> запись математических выражений в привычной для человека
                            алгебраической форме;</li>
                        <li>возможность конструировать новые типы данных;</li>
                        <li> создание собственных функций, библиотек;</li>
                        <li> возможностью использовать переменные с понятными человеку именами;</li>
                        <li> слабая зависимость от используемой вычислительной машины.</li>
                    </ul>
                    <aside class="notes">
                        Языки высокого уровня в настоящее время в большинстве своем являются универсальными, т.е. на них
                        можно составить любую программу. Транслятор, преобразующий программу, написанную на таком языке,
                        в
                        машинный код, стал более сложным, в нем появились оптимизирующие функции. В одних случаях целью
                        оптимизации является компактность программного кода, в других - высокая скорость вычислений.
                    </aside>
                </section>
                <section>
                    <p>Свойства языков высокого уровня:</p>
                    <ul>
                        <li> запись математических выражений в привычной для человека
                            алгебраической форме;</li>
                        <li>возможность конструировать новые типы данных;</li>
                        <li> создание собственных функций, библиотек;</li>
                        <li> возможностью использовать переменные с понятными человеку именами;</li>
                        <li> слабая зависимость от используемой вычислительной машины.</li>
                    </ul>
                    <aside class="notes">

                        Для подготовки текста программ возникла необходимость в достаточно универсальном текстовом
                        редакторе, в отладчике, сборщике исполняемого кода из отдельных модулей, подготовленных разными
                        разработчиками. Весь этот набор инструментов обычно называют средой программирования или средой
                        разработки.
                    </aside>
                </section>
                <section>
                    <p>Свойства языков высокого уровня:</p>
                    <ul>
                        <li> запись математических выражений в привычной для человека
                            алгебраической форме;</li>
                        <li>возможность конструировать новые типы данных;</li>
                        <li> создание собственных функций, библиотек;</li>
                        <li> возможностью использовать переменные с понятными человеку именами;</li>
                        <li> слабая зависимость от используемой вычислительной машины.</li>
                    </ul>
                    <aside class="notes">
                        С течением времени был создан целый ряд универсальных языков программирования (FORTRAN, Pascal,
                        Си,
                        Modula-2, Ada), многие из которых являлись предпочтительнее один другого в зависимости от класса
                        решаемых на них задач. Параллельно с этим появились и ярко выраженные проблемно-ориентированные
                        языки, такие как COBOL, GPSS, Simula, Snobol, ориентированные на достаточно узкие классы задач.
                    </aside>
                </section>
                <section>
                    <p>Свойства языков высокого уровня:</p>
                    <ul>
                        <li> запись математических выражений в привычной для человека
                            алгебраической форме;</li>
                        <li>возможность конструировать новые типы данных;</li>
                        <li> создание собственных функций, библиотек;</li>
                        <li> возможностью использовать переменные с понятными человеку именами;</li>
                        <li> слабая зависимость от используемой вычислительной машины.</li>
                    </ul>
                    <aside class="notes">
                        Языки высокого уровня позволили достичь определенной степени абстракции проблемы при составлении
                        программы и позволили представить ее в достаточно наглядной форме. Это привело к тому, что языки
                        программирования стали не только языками общения человека с машиной, но и языками общения
                        человека с
                        человеком. Программисту стало проще показать программу на достаточно формализованном языке, чем
                        объяснять алгоритм "на пальцах". И этим свойством начали активно пользоваться.
                    </aside>
                </section>
                <section>
                    <p>Свойства языков высокого уровня:</p>
                    <ul>
                        <li> запись математических выражений в привычной для человека
                            алгебраической форме;</li>
                        <li>возможность конструировать новые типы данных;</li>
                        <li> создание собственных функций, библиотек;</li>
                        <li> возможностью использовать переменные с понятными человеку именами;</li>
                        <li> слабая зависимость от используемой вычислительной машины.</li>
                    </ul>
                    <aside class="notes">


                        В качестве вспомогательного средства общения и проектирования программ появились псевдокоды -
                        некое
                        подобие языка высокого уровня. Псевдокод имеет достаточно слабо формализованное описание
                        синтаксиса,
                        позволяет выразить практически любые вычисления и вполне понятен любому человеку, хоть раз
                        использовавшему какой-либо язык программирования. Текст на псевдокоде не обязательно должен быть
                        так
                        же детален, как программа на языке программирования. Например, блок-схемы не определяют команды,
                        но
                        являются одновременно достаточно точным и простым синтаксисом описания алгоритмов.
                    </aside>
                </section>
                <section>
                    <p>Функции языка высокого уровня:</p>
                    <ul>
                        <li> средство общения с вычислительной машиной;</li>
                        <li> средство общения программистов между собой;</li>
                        <li> средство мышления;</li>
                        <li> средства обучения;</li>
                        <li> средства публикации.</li>
                    </ul>
                    <aside class="notes">
                        Очевидно, что весьма сложно найти язык, одинаково подходящий для всех областей применения.

                        Создание больших и сложныиальные технологические приех программных комплексов привлекло внимание
                        к инженерным методам их
                        разработки, т.е. появилась необходимость производить разработку систем с определенными
                        характеристиками, в заданные сроки и с использованием ограниченных ресурсов. В программировании
                        стали развиваться спецмы, которые поддерживают коллективную
                        разработку, гарантируют определенное качество результата, обеспечивают возможность длительного
                        (десятки лет) сопровождения программной системы.
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h2>Программная инженерия</h2>
                </section>
                <section>

                    <img src="./3.jpg" /> <img src="./4.jpg" />
                    <aside class="notes">
                        Сильное влияние на развитие технологии программирования оказал Э. Дейкстра (Edsger W. Dijkstra),
                        предложивший метод структурного программирования. Одновременно с публикациями его идей стали
                        достоянием гласности работы Ч. Хоара, показавшего, что любая программа может быть математически
                        (формально) проанализирована, и это позволяет избежать части ошибок при использовании
                        соответствующих формальных приемов проверки программ и алгоритмов.
                    </aside>
                </section>
                <section>
                    <img src="./3.jpg" /> <img src="./4.jpg" />
                    <aside class="notes">

                        Дейкстра же заметил, что язык программирования влияет на способ мышления. Освоение
                        алгоритмических языков программирования заставляет мыслить формальными категориями, "прививает"
                        определенную логику, которая несколько отличается от логики написания программ на
                        машинно-ориентированном языке. Программирование - это конструирование достаточно сложных
                        объектов с большим количеством связей, и чтобы конструировать, следует последовательно
                        использовать
                        элементарные принципы конструирования, начиная от проектирования функций, модулей, абстрактных
                        типов
                        данных и заканчивая построением сложной системы.
                    </aside>
                </section>
                <section>
                    <ul>
                        <li>необходимость нескольких разработчиков;</li>
                        <li>оценка программного продукта пользовательским требованиям;</li>
                        <li>сетификация и аттестация ПО;</li>
                    </ul>
                    <aside class="notes">
                        Сложность современных программных продуктов уже достигла такого уровня, когда для создания
                        конечной системы необходимо участие нескольких разработчиков в течение достаточно долгого
                        времени. При
                        этом встает проблема координации их действий, фиксации всех договоренностей. Особое внимание
                        должно
                        быть уделено разработке исходных требований и их согласованию с конечными пользователями и
                        заказчиками.
                        Разработка программ уже стала инженерией, и четкое следование заранее выработанному процессу
                        построения системы - залог успеха.
                    </aside>
                </section>
                <section>
                    <ul>
                        <li>необходимость нескольких разработчиков;</li>
                        <li>оценка программного продукта пользовательским требованиям;</li>
                        <li>сетификация и аттестация ПО;</li>
                    </ul>
                    Кроме написания работающей программы существует проблема оценки степени соответствия этой
                    программы
                    предъявляемым к ней требованиям. Тут необходимо проводить тестирование, которое не всегда будет
                    являться полным, но в конечном итоге должно привести к появлению качественного продукта, т.е.
                    программы, соответствующей ожиданиям.
                    </aside>
                </section>
                <section>
                    <ul>
                        <li>необходимость нескольких разработчиков;</li>
                        <li>оценка программного продукта пользовательским требованиям;</li>
                        <li>сетификация и аттестация ПО;</li>
                    </ul>
                    <aside class="notes">

                        В некоторых критических к ошибкам областях применения программных средств предусмотрена
                        процедура
                        сертификации или аттестации. Ее итогом является решение сертифицирующего органа о возможности
                        применения программного продукта в той или иной области. Соответственно, существуют положения,
                        регламентирующие процедуру сертификации, которые предъявляют определенные требования и к
                        процедуре
                        разработки программного обеспечения.
                    </aside>
                </section>
                <section>
                    <ul>
                        <li>необходимость нескольких разработчиков;</li>
                        <li>оценка программного продукта пользовательским требованиям;</li>
                        <li>сетификация и аттестация ПО;</li>
                    </ul>
                    <aside class="notes">
                        Примером такого документа может служить ГОСТ Р 51904-2002 "Программное обеспечение встроенных
                        систем. Общие требования к разработке и документированию". Во многих случаях он требует
                        выполнения в
                        процессе тестирования каждой команды машинного программного кода. Это позволяет убедиться не
                        только
                        в том, что программа делает то, что нужно, но и быть уверенным, что она не делает того, что не
                        предусмотрено требованиями.
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h2>Системы реального времени</h2>
                </section>
                <section>
                    <p>СРВ &mdash; интервал времени, за который исходные данные должны быть обработаны и сформирован
                        результат, соизмерим со временем выполнения команд машины.</p>
                    <aside class="notes">
                        Существует особый класс задач, решаемых средствами вычислительной техники, когда время
                        становится критическим фактором, играющим особую роль при разработке алгоритма программы. Как
                        правило, интервал времени, за который исходные данные должны быть обработаны и сформирован
                        результат, соизмерим со временем выполнения команд машины (отличаются от него менее чем на
                        два-три порядка). Такие системы принято называть системами реального времени (СРВ). Спецификой
                        СРВ является то, что управление вычислениями зависит не только от значений исходных данных, но и
                        от момента их появления. Кроме того, во многих случаях реакция системы должна уложиться в очень
                        ограниченный интервал времени (10-100 миллисекунды). Это приводит к необходимости искать
                        специальные методы обработки, гарантирующие завершение вычислений к определенному моменту
                        времени.
                    </aside>
                </section>
                <section>
                    <p>СРВ является то, что это встроенные системы, т.е. такая система входит в состав некой более общей
                        системы.</p>
                    <aside class="notes">
                        Дополнительной спецификой большинства СРВ является то, что это встроенные системы, т.е.
                        такая
                        система входит в состав некой более общей системы, включающей в себя датчики, каналы связи,
                        исполнительное оборудование и т.п. Простым примером может служить система управления
                        двигателем
                        современного автомобиля или блок управления современного мобильного телефона, телевизора.
                    </aside>
                </section>
                <section>
                    <p>Стоимость программной ошибки многократно увеличивается.</p>
                    <aside class="notes">
                        Особенность программного обеспечения встроенных СРВ заключается в том, что стоимость
                        программной
                        ошибки многократно увеличивается за счет тиражирования ее во всей серии встроенного
                        оборудования, а устранение может быть связано с огромными затратами на возврат проданных
                        автомобилей или телефонов, телевизоров в пункты сервисного обслуживания.
                    </aside>
                </section>
                <section>
                    <p>Дефицит внешнего оборудования, ресурсов разработки и отладки.</p>
                    <aside class="notes">
                        Наконец, процесс разработки встроенного программного обеспечения связан с рядом
                        особенностей,
                        обусловленных спецификой применяемых в подобных системах вычислителей. Как правило, они не
                        имеют
                        достаточного внешнего оборудования для возможности поддержки функционирования
                        инструментального
                        программного обеспечения: текстовых редакторов для написания программ, трансляторов, сред
                        отладки и т.п. Но с другой стороны, они могут обладать рядом специфических черт, не присущих
                        универсальным вычислителям: энергонезависимая память, сверхбыстрые регистры, специальные
                        каналы
                        связи и т.п.
                    </aside>
                </section>
                <section>
                    <p>Четко различается среда разработки программного обеспечения и среда выполнения программного кода.
                    </p>
                    <aside class="notes">

                        Таким образом, при разработке встроенных СРВ часто приходится четко различать среду
                        разработки
                        программного обеспечения и среду выполнения программного кода - среду эксплуатации. Иногда
                        используют термины: инструментальная среда и целевая среда. При этом, как правило, система
                        команд инструментального вычислителя существенно отличается от системы команд целевого
                        вычислителя. Поэтому в состав среды разработки обычно включается эмулятор целевого
                        процессора
                        (программный или аппаратный) и модели его внешнего оборудования для поддержки процесса
                        выполнения целевой программы на универсальном процессоре инструментальной машины.
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h2>Жизненный цикл ПО</h2>
                    <aside class="notes">
                        <b>Жизненный цикл разработки программного обеспечения (SDLC, Software Development Life
                            Cycle)</b> — это
                        структурированный подход к созданию программных продуктов, охватывающий все этапы от зарождения
                        идеи
                        до вывода готового продукта на рынок и его дальнейшей поддержки.<br />
                        <b>Цель SDLC</b> — обеспечить эффективное
                        управление процессом разработки, повысить качество создаваемого программного обеспечения и
                        оптимизировать использование ресурсов.
                    </aside>
                </section>

                <section>
                    <h2>Этапы SDLC</h2>
                    <ul>
                        <li>Планирование </li>
                        <li>Анализ требований</li>
                        <li>Проектирование </li>
                        <li>Разработка</li>
                        <li>Тестирование</li>
                        <li>Развёртывание</li>
                        <li>Поддержка и обслуживание</li>
                    </ul>
                    <aside class="notes">
                        Планирование — определяются цели проекта, его объём и ресурсы.<br />
                        Анализ требований — команда собирает и анализирует требования к программному обеспечению
                        (интервью с
                        заинтересованными сторонами, опросы пользователей, изучение существующих систем). Результатом
                        становится документ с чёткими требованиями, который служит основой для проектирования.<br />
                        Проектирование — после сбора требований команда приступает к проектированию системы (определение
                        архитектуры системы, создание интерфейсов, проектирование базы данных).<br />
                        Разработка — разработчики создают программный продукт на основе спецификаций, определённых на
                        предыдущих этапах.<br />
                        Тестирование — после завершения разработки начинается этап тестирования, который включает
                        модульное,
                        интеграционное и системное тестирование.<br />
                        Развёртывание — после успешного тестирования программное обеспечение готово к развёртыванию
                        (установка системы на серверы, настройка окружения, обучение пользователей).<br />
                        Поддержка и обслуживание — после развёртывания начинается этап поддержки: исправление ошибок,
                        обновления и улучшения, ответы на вопросы пользователей.
                    </aside>
                </section>
                <section>
                    <h2>Методологии</h2>
                    <ul>
                        <ul>
                            <li>Строгие модели</li>
                            <li>Гибкие модели </li>
                        </ul>
                        <aside class="notes">
                            Для стабильности и управляемости процессов на этапах SDLC используют различные модели
                            жизненного цикла. Например: kaiten.ru
                            <ul>
                                <li>Строгие модели — каскадная и V-образная, предполагают движение только вперёд —
                                    возврат на предыдущий этап в них невозможен.</li>
                                <li>Гибкие модели — например, Agile, позволяют запускать продукт по частям и постепенно
                                    улучшать его через короткие итерации.</li>
                            </ul>
                        </aside>
                </section>
                <section>
                    <h2>Стандарты</h2>
                    <ul>
                        <li>ISO/IEC 12207:2008</li>
                        <li>ГОСТ Р ИСО/МЭК 12207-2010</li>
                    </ul>
                    <aside class="notes">
                        В международном стандарте ISO/IEC 12207:2008 описан жизненный цикл программного обеспечения,
                        включая цель, выходы, действия и задачи каждого из этапов. Российский аналог — ГОСТ Р ИСО/МЭК
                        12207-2010 «Информационная технология. Системная и программная инженерия. Процессы жизненного
                        цикла программных средств».
                    </aside>
                </section>
                <section>
                    <h2>Инструменты</h2> <!-- 6 -->
                    <ul>
                        <li>Инструменты управления требованиями</li>
                        <li>Средства планирования проектов</li>
                        <li>Системы управления задачами (таск-трекеры)</li>
                        <li>Системы контроля версий</li>
                    </ul>
                    <aside class="notes">
                        Для внедрения и эффективного управления процессами SDLC используются специализированные
                        инструменты. Некоторые из них:
                        <ul>
                            <li> Инструменты управления требованиями — помогают собирать, документировать и
                                отслеживать требования к продукту.</li>
                            <li> Средства планирования проектов — позволяют создавать планы, распределять задачи и
                                ресурсы.</li>
                            <li> Системы управления задачами (таск-трекеры) — облегчают создание, назначение и
                                отслеживание выполнения задач.</li>
                            <li> Системы контроля версий — управляют изменениями в коде и других артефактах проекта.
                            </li>
                        </ul>
                    </aside>
                </section>
                <!-- <section>
                    <img src="./04.jpg" />
                </section>
                <section>
                    <img src="./05.png" style="background: white;" />
                </section> -->
            </section>
            <section>
                <section>
                    <h2>Планирование и анализ требований</h2>
                    <ul>
                        <li>Описание задач продукта;</li>
                        <li>Опрос стейкхолдеров;</li>
                        <li>Выявление аудитории пользователей;</li>
                        <li>Оценка ресурсов;</li>
                        <li>Согласование критериев.</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Описание задач, которые должен решать продукт;</li>
                            <li>Опрос стейкхолдеров;</li>
                            <li>Выявление аудитории, которая будет пользоваться решением;</li>
                            <li>Оценка ресурсов, которые нужны для реализации: количество сотрудников, время, бюджет;
                            </li>
                            <li>Согласование критериев, по которым будут оценивать успешность решения.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <p>Участники этапа:</p>
                    <ul>
                        <li>руководитель проекта</li>
                        <li>владелец продукта</li>
                        <li>заказчик</li>
                        <li>бизнес-аналитик</li>
                        <li>стейкхолдеры</li>
                    </ul>
                </section>
                <section>
                    <h2>Стейкхолдеры</h2>
                    <img src="./5-0.jpg" />
                </section>
                <section>
                    <h3>Типы стейкхолдеров</h3>
                    <img src="./5.jpg" />
                </section>
                <section>
                    <h3>Группы стейкхолдеров</h3>
                    <img src="./6.jpg" />
                </section>
                <section>
                    <h3>Владелец продукта</h3>
                    <b>Product Owner, PO</b> — специалист, который отвечает за создание, развитие и управление продуктом
                    на всех этапах его жизненного цикла.
                    <aside class="notes"> от идеи до выпуска и дальнейшего улучшения. <br />
                        Его задача — быть связующим звеном между бизнесом и разработкой, максимизировать ценность
                        продукта для пользователей и бизнеса.
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h3>Определение требований</h3>
                </section>
                <section>
                    <ul>
                        <li>Оценка рисков;</li>
                        <li>Выбор методологии работы;</li>
                        <li>Описание пользовательских сценариев;</li>
                        <li>подготовка SRS;</li>
                        <li>подготовка ИСР.</li>
                    </ul>

                    <aside class="notes">
                        <ul>
                            <li>Оценка рисков;</li>
                            <li>Выбор методологии работы;</li>
                            <li>Описание пользовательских сценариев;</li>
                            <li>подготовка SRS — документации с информацией о функциональных и нефункциональных
                                требованиях;</li>
                            <li>подготовка ИСР — иерархической структуры работ. <br />
                                Процесс разделяют на более мелкие элементы, чтобы упростить управление и понять, в каком
                                порядке нужно выполнять проект, и какие задачи можно делать параллельно друг другу.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <p>Участники этапа:</p>
                    <ul>
                        <li>руководитель проекта</li>
                        <li>владелец продукта</li>
                        <li>команда разработки</li>
                        <li>архитектор ПО</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h3>Проектирование</h3>
                </section>
                <section>
                    <p>Архитектура системы:</p>
                    <ul>
                        <li>верхнеуровневая</li>
                        <li>низкоуровневая</li>
                    </ul>
                    <aside class="notes">
                        Чтобы разработчики понимали, как система будет работать, и чтобы избежать ошибок на этапе
                        разработки, создают архитектуру системы.<br />
                        При <b>верхнеуровневом</b> создают общую структуру системы, а <b>низкоуровневое</b>
                        проектирование отличается большей детализацией.<br />
                        Результатом этапа будет проектная документация с информацией, которая необходима для реализации
                        решения.
                    </aside>
                </section>
                <section>
                    <h4>Верхнеуровневое проектирование</h4>
                    <ul>
                        <li>Основные компоненты системы — модули, сервисы или подсистемы</li>
                        <li>Принцип взаимодействия компонентов</li>
                        <li>Общая архитектура системы</li>
                        <li>Зависимость решения от других систем</li>
                        <li>Прототип интерфейса</li>
                    </ul>
                </section>
                <section>
                    <h4>Низкоуровневое проектирование</h4>
                    <ul>
                        <li>Принцип работы отдельных компонентов системы</li>
                        <li>Алгоритмы, структуры данных, логика работы внутри каждого модуля</li>
                        <li>Детали реализации — классы, методы или функции будут созданы</li>
                        <li>Взаимодействие с базами данных, API или другими внешними системами</li>
                    </ul>
                </section>
                <section>
                    <p>Участники этапа:</p>
                    <ul>
                        <li>архитектор</li>
                        <li>UX/UI-дизайнер</li>
                        <li>QA-инженер</li>
                        <li>команда разработки</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>UX-дизайн (User Experience — «пользовательский опыт») отвечает за то, как интерфейс
                            работает.
                        </li>
                        <li>UI-дизайн (User Interface — «пользовательский интерфейс») отвечает за то, как интерфейс
                            выглядит.
                        </li>
                        <li>QA-инженер (Quality Assurance engineer, инженер по обеспечению качества)</li>
                        <li>Архитектор ПО — отвечает за структуру и логику работы
                            IT-системы.</li>
                    </ul>
                    <aside class="notes">Одна часть не может существовать без другой. Сейчас трудно себе представить,
                        что можно разрабатывать интерфейс и не задумываться о том, как он будет выглядеть, и наоборот —
                        оформлять UI в отрыве от проектирования UX.</aside>
                </section>
            </section>
            <section>
                <section>
                    <h3>Разработка</h3>
                </section>
                <section>
                    <p>Участники этапа:</p>
                    <ul>
                        <li>Техлид</li>
                        <li>команда разработки</li>
                        <li>DevOps-инженер</li>
                        <li>QA-инженер</li>
                    </ul>
                </section>
                <section>
                    <p>DevOps-инженер — специалист, который объединяет процессы разработки и эксплуатации программного
                        обеспечения.</p>
                    <p>Техлид &mdash; это роль, требующая сочетания технической компетентности, стратегического мышления
                        и лидерских способностей.</p>
                </section>
            </section>
            <section>
                <section>
                    <h3>Тестирование</h3>
                </section>
                <section>
                    <p>Участники этапа:</p>
                    <ul>
                        <li>QA-инженеры
                        <li> разработчики</li>
                        <li> автоматизаторы тестирования</li>
                        <li> потенциальные пользователи в случае User Acceptance Testing</li>
                        </li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h3>Развертывание</h3>
                </section>
                <section>
                    <p>Участники этапа:</p>
                    <ul>
                        <li>DevOps-инженер</li>
                        <li>разработчики</li>
                        <li>руководитель проекта</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h3>Поддержка и сопровождение</h3>
                </section>
                <section>
                    <p>Участники этапа:</p>
                    <ul>
                        <li>DevOps-инженер</li>
                        <li>техническая поддержка</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h3>«Смерть» ПО</h3>

                </section>
                <section>
                    <ul>
                        <li>aрхивирование данных</li>
                        <li>уведомление пользователей</li>
                    </ul>
                    <aside class="notes">
                        На этом этапе команда прекращает обслуживать продукт или заменяет его новой версией, потому что
                        ПО устарело или такая инициатива поступила от заказчика.
                    </aside>
                </section>
                <section>
                    <p>Участники этапа:</p>
                    <ul>
                        <li>DevOps-инженер</li>
                        <li>техническая поддержка</li>
                    </ul>
                </section>
            </section>
            <section>
                <h2>Модели жизненного цикла ПО</h2>
            </section>
            <section>
                <img src="./7.png" />
                <aside class="notes">После развертывания команда собирает фидбек и на его основе выпускает новые
                    релизы</aside>
            </section>
            <section>
                <section>
                    <h3>Каскадная модель</h3>
                    <img src="./8.png" />
                    <aside class="notes">Один этап перетекает в другой, и так вплоть до релиза </aside>
                </section>
                <section>
                    <p>Плюсы:</p>
                    <ul>
                        <li>Низкий риск ошибок за счет детальной документации;</li>
                        <li>Прозрачность процессов для заказчика — он знает, сколько времени уйдет на каждый этап.</li>
                        <li>Полное документирование каждого этапа до начала разработки;</li>
                    </ul>
                </section>
                <section>
                    <p>Минусы:</p>
                    <ul>
                        <li>Перед стартом нужно подготовить обширную техническую документацию</li>
                        <li>Сложно учесть все требования до старта разработки</li>
                        <li>Нет гибкости — если появились новые требования на этапе разработке, то откатить работу назад
                            не получится</li>
                        <li>Заказчик видит результат в конце разработки — если итог его не устроит, придется начинать
                            сначала</li>
                    </ul>
                </section>
                <section>
                    <p>Когда подходит:</p>
                    <ul>
                        <li>Четкие, заранее известные требования</li>
                        <li>Работа ведется по строгим регламентам</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Есть четкие и заранее известные требования, которые не будут меняться на этапе
                                разработки
                            </li>
                            <li>Работа должна идти по строгим регламентам — такое требование может быть актуальным для
                                госучреждений или банковских систем</li>
                        </ul>

                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h2>V-образная модель</h2>
                    <aside class="notes">Это расширенный вариант каскадной модели, который делает упор на тестировании.
                        Устроена модель так: до начала разработки после каждого этапа проводят тестирования разного
                        уровня, а после разработки ПО проходит те же самые тестирования в обратном порядке и только
                        потом уходит в релиз. </aside>
                </section>
                <section>
                    <img src="./9.png" />
                </section>
                <section>
                    <ul>
                        <li>Верификация — проверка ПО соответстветствие правилам и требованиям в документации.</li>
                        <li>Валидация — проверка готового ПО на соответствие ожиданиям заказчика.</li>
                    </ul>
                </section>
                <section>
                    <p>Плюсы:</p>
                    <ul>
                        <li>Ошибки выявляют на ранних этапах</li>
                        <li>Четкая структура</li>
                        <li>Акцент на тестировании</li>
                        <li>Высокая степень анализа рисков</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Ошибки выявляют на ранних этапах, что снижает затраты на их исправление;</li>
                            <li>За счет четкой структуры подходит для проектов с ясными и неизменными требованиями;</li>
                            <li>Акцент на тестировании обеспечивает надежность продукта;</li>
                            <li>Высокая степень анализа рисков.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <p>Минусы:</p>
                    <ul>
                        <li>Такая же строгая, как и каскадная</li>
                        <li>Разработка обходится дорого</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Такая же строгая, как и каскадная, поэтому при появлении новых требований все придется
                                начинать заново;</li>
                            <li>Разработка обходится дорого.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <p>Когда подходит модель:</p>
                    <ul>
                        <li>Есть четкие и заранее известные требования, которые не будут меняться во время разработки;
                        </li>
                        <li>Работа должна идти по строгим регламентам;</li>
                        <li>Проект предполагает большое тестовое покрытие.</li>
                    </ul>
                </section>
            </section>
            <section>
                <section>
                    <h3>Итеративная модель</h3>
                </section>
                <section>
                    <img src="./10.png" />
                    <aside class="noteas">
                        Позволяет обновлять требования к продукту после старта разработки. Для этого проект
                        дробят на части и сначала выпускают MVP-версию, а затем итерациями доводят решение до ума.<br />
                        По ходу разработки требования к ПО можно менять в зависимости от обратной связи пользователей,
                        заказчика или изменений на рынке. Цикл повторяется до тех пор, пока вся система не будет
                        готова.<br />
                        MVP — продукт, обладающий минимальными, но достаточными для удовлетворения первых потребителей
                        функциями.
                    </aside>
                </section>
                <section>
                    <p>Каждая итерация проекта — это мини-проект.</p>
                </section>
                <section>
                    <p>Плюсы:</p>
                    <ul>
                        <li> Возможность быстро выкатить ПО</li>
                        <li> Заказчик видит промежуточные результаты и может корректировать требования</li>
                        <li> Быстрая обратная связь от пользователей</li>
                        <li> Проще находить конфликты между требованиям</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                        </ul>
                    </aside>
                </section>
                <section>
                    <p>Минусы:</p>
                    <ul>
                        <li>Могут возникнуть сложности с созданием рабочей архитектуры</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Могут возникнуть сложности с созданием рабочей архитектуры, так как изначально не всегда
                                известны все требования.</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <p>Когда подходит модель:</p>
                    <ul>
                        <li>Рабочее решение нужно в короткие сроки</li>
                        <li>Требования не до конца ясны и могут меняться в процессе работы</li>
                        <li>Проект очень большой, а ресурсов немного, поэтому приходится разбивать продукт на части и
                            делать его постепенно</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Рабочее решение нужно в короткие сроки</li>
                            <li>Требования не до конца ясны и могут меняться в процессе работы</li>
                            <li>Проект очень большой, а ресурсов немного, поэтому приходится разбивать продукт на части
                                и
                                делать его постепенно</li>
                        </ul>
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h3>Итеративная модель</h3>
                </section>
                <section>
                    <img src="./11.png" />
                    <aside class="noteas">
                        При работе по этой модели продукт создают по частям, или инкрементам. Каждая часть добавляет
                        новую функциональность к уже существующей системе. В отличие от итеративной модели, где каждая
                        итерация может пересматривать и улучшать предыдущие результаты, в инкрементной модели каждая
                        часть — это законченный кусок функционала, который можно использовать.
                    </aside>
                </section>
                <section>
                    <p>Плюсы:</p>
                    <aside class="notes">

                    </aside>
                </section>
                <section>
                    <p>Минусы:</p>
                    <aside class="notes">

                    </aside>
                </section>
                <section>
                    <p>Когда подходит модель:</p>
                    <ul>

                    </ul>
                    <aside class="notes">
                        <ul>

                        </ul>
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h3>Спиральная модель</h3>
                </section>
                <section>
                    <img src="./11.png" />
                    <aside class="noteas">
                        Модель объединяет в себе преимущества каскадной и итеративной моделей, но делает большой упор на
                        анализ рисков. То есть, команда уделяет много времени планированию и при этом в будущем может
                        дорабатывать решение. Еще одна особенность модели в том, что процесс разработки делится на
                        циклы, которые изображают как витки спирали.
                    </aside>
                </section>
                <section>
                    <ul>
                        <li>планирование</li>
                        <li>анализ рисков</li>
                        <li>разработка и тестирование</li>
                        <li>оценка и планирование следующего витка</li>
                    </ul>
                </section>
                <section>
                    <p>Плюсы:</p>
                    <ul>
                        <li>Риски находят на ранних этапах</li>
                        <li>Можно вносить изменения в проект по мере его развития</li>
                        <li>Подходит для крупных систем</li>
                    </ul>
                    <aside class="notes">
                        <li>Риски находят на ранних этапах, что снижает вероятность проблем в будущем</li>
                        <li>Можно вносить изменения в проект по мере его развития</li>
                        <li>Подходит для крупных систем, где много неопределенности и высокие требования к надежности
                        </li>
                    </aside>
                </section>
                <section>
                    <p>Минусы:</p>
                    <ul>
                        <li>Многочисленные циклы растягивают разработку и делают ее дороже</li>
                        <li>Каждое новое требование заказчика запускает новый виток</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li> Многочисленные циклы растягивают разработку и делают ее дороже</li>
                            <li>Каждое новое требование заказчика запускает новый виток. Это делает разработку дороже,
                                так как нужно снова тратить ресурсы на анализ</li>
                        </ul>
                    </aside>
                </section>
                <section>
                    <p>Когда подходит модель:</p>
                    <ul>
                        <li>Пользователи сами не до конца понимают, что им нужно</li>
                        <li>Требования к проекту слишком сложные</li>
                        <li>Успех проекта не гарантирован</li>
                        <li>В проекте используют новые технологии</li>
                    </ul>
                    <aside class="notes">
                        <ul>
                            <li>Пользователи сами не до конца понимают, что им нужно</li>
                            <li>Требования к проекту слишком сложные и могут меняться по ходу работы</li>
                            <li>Успех проекта не гарантирован, и нужно заранее оценить риски, чтобы решить, стоит ли
                                продолжать работу</li>
                            <li>В проекте используют новые технологии, которые еще не до конца изучены, и есть риск, что
                                они не дадут ожидаемого результата</li>
                        </ul>
                    </aside>
                </section>
            </section>
            <section>
                <section>
                    <h3>Agile</h3>
                </section>
            </section>
            <section>
                <section>
                    <h3>Scrum</h3>
                </section>
            </section>
            <section>
                <section>
                    <h3>Kanban</h3>
                </section>
            </section>
            <section>
                <section>
                    <h3>Как выбрать правильную модель SDLC</h3>
                </section>
            </section>
            <section>
                <section>
                    <h3>Как эффективно управлять этапами SDLC</h3>
                </section>
            </section>
        </div>
    </div>

    <script src="../reveal.js"></script>
    <script src="../notes.js"></script>
    <!-- <script src="markdown.js"></script> -->
    <!-- <script src="../math/math.js"></script> -->
    <script src="../highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,
            showSlideNumber: 'all',
            slideNumber: "true",
            transition: "none",
            // Learn about plugins:</b> https://revealjs.com/plugins/
            plugins: [RevealHighlight, RevealNotes]
            // plugins: [RevealHighlight, RevealNotes, RevealMath.KaTeX]
        });
    </script>
</body>

</html>